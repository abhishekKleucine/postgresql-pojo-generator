package postgresConnect;

import java.io.FileWriter;
import java.io.IOException;
import java.sql.*;
import java.util.*;

public class PojoGenerator {
    static final String DB_URL = "jdbc:postgresql://localhost:5432/qa_";
    static final String DB_USER = "postgres";
    static final String DB_PASS = "postgres";
    static final String OUTPUT_FOLDER = "src/postgresConnect/generated/";
    
    public static void main(String[] args) {
        // Create output directory
        new java.io.File(OUTPUT_FOLDER).mkdirs();
        
        try (Connection conn = DriverManager.getConnection(DB_URL, DB_USER, DB_PASS)) {
            DatabaseMetaData meta = conn.getMetaData();
            ResultSet tables = meta.getTables(null, "public", "%", new String[]{"TABLE"});

            while (tables.next()) {
                String tableName = tables.getString("TABLE_NAME");
                String className = toCamelCase(tableName, true);

                Map<String, ColumnInfo> columns = new LinkedHashMap<>();
                Set<String> primaryKeys = getPrimaryKeys(meta, tableName);
                Map<String, String> foreignKeys = getForeignKeys(meta, tableName);
                Map<String, IndexInfo> indexes = getIndexes(meta, tableName);
                Map<String, String> checkConstraints = getCheckConstraints(conn, tableName);
                Map<String, String> uniqueConstraints = getUniqueConstraints(conn, tableName);

                ResultSet cols = meta.getColumns(null, "public", tableName, null);
                while (cols.next()) {
                    String colName = cols.getString("COLUMN_NAME");
                    String dataType = cols.getString("TYPE_NAME");
                    int columnSize = cols.getInt("COLUMN_SIZE");
                    boolean nullable = cols.getInt("NULLABLE") == DatabaseMetaData.columnNullable;
                    boolean autoIncrement = "YES".equals(cols.getString("IS_AUTOINCREMENT"));
                    String defaultValue = cols.getString("COLUMN_DEF");
                    
                    ColumnInfo colInfo = new ColumnInfo();
                    colInfo.name = colName;
                    colInfo.javaType = mapToJavaType(dataType);
                    colInfo.sqlType = dataType;
                    colInfo.size = columnSize;
                    colInfo.nullable = nullable;
                    colInfo.autoIncrement = autoIncrement;
                    colInfo.defaultValue = defaultValue;
                    colInfo.isPrimaryKey = primaryKeys.contains(colName);
                    colInfo.isForeignKey = foreignKeys.containsKey(colName);
                    colInfo.foreignKeyReference = foreignKeys.get(colName);
                    colInfo.hasCheckConstraint = checkConstraints.containsKey(colName);
                    colInfo.checkConstraintDefinition = checkConstraints.get(colName);
                    colInfo.hasUniqueConstraint = uniqueConstraints.containsKey(colName);
                    colInfo.uniqueConstraintName = uniqueConstraints.get(colName);
                    
                    columns.put(colName, colInfo);
                }

                generateAdvancedPojoFile(className, tableName, columns, indexes, checkConstraints, uniqueConstraints);
            }

            System.out.println("Advanced POJOs with complete constraint handling generated in: " + OUTPUT_FOLDER);

        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    static void generateAdvancedPojoFile(String className, String tableName, 
                                       Map<String, ColumnInfo> columns, 
                                       Map<String, IndexInfo> indexes,
                                       Map<String, String> checkConstraints,
                                       Map<String, String> uniqueConstraints) throws IOException {

        StringBuilder sb = new StringBuilder();
        
        // Package declaration
        sb.append("package postgresConnect.generated;\n\n");
        sb.append("import java.io.Serializable;\n");
        sb.append("import java.util.Objects;\n\n");

        // Class documentation with complete constraint information
        sb.append("/**\n");
        sb.append(" * Advanced POJO class for table: ").append(tableName).append("\n");
        sb.append(" * Generated by AdvancedPojoBatchGenerator\n");
        sb.append(" * Includes: Primary Keys, Foreign Keys, Indexes, Check Constraints, Unique Constraints, Default Values\n");
        sb.append(" * \n");
        sb.append(" * Table Information:\n");
        sb.append(" * - Table Name: ").append(tableName).append("\n");
        
        // Document primary keys
        List<String> pkList = new ArrayList<>();
        for (Map.Entry<String, ColumnInfo> entry : columns.entrySet()) {
            if (entry.getValue().isPrimaryKey) {
                pkList.add(entry.getKey());
            }
        }
        if (!pkList.isEmpty()) {
            sb.append(" * - Primary Keys: ").append(String.join(", ", pkList)).append("\n");
        }
        
        // Document indexes
        if (!indexes.isEmpty()) {
            sb.append(" * \n");
            sb.append(" * Indexes:\n");
            for (IndexInfo idx : indexes.values()) {
                sb.append(" * - ").append(idx.name);
                if (idx.unique) sb.append(" (UNIQUE)");
                sb.append(": ").append(String.join(", ", idx.columns)).append("\n");
            }
        }
        
        // Document unique constraints
        if (!uniqueConstraints.isEmpty()) {
            sb.append(" * \n");
            sb.append(" * Unique Constraints:\n");
            for (Map.Entry<String, String> entry : uniqueConstraints.entrySet()) {
                sb.append(" * - ").append(entry.getValue()).append(": ").append(entry.getKey()).append("\n");
            }
        }
        
        // Document check constraints
        if (!checkConstraints.isEmpty()) {
            sb.append(" * \n");
            sb.append(" * Check Constraints:\n");
            for (Map.Entry<String, String> entry : checkConstraints.entrySet()) {
                sb.append(" * - ").append(entry.getKey()).append(": ").append(entry.getValue()).append("\n");
            }
        }
        
        // Document foreign keys
        boolean hasForeignKeys = false;
        for (Map.Entry<String, ColumnInfo> entry : columns.entrySet()) {
            if (entry.getValue().isForeignKey) {
                if (!hasForeignKeys) {
                    sb.append(" * \n");
                    sb.append(" * Foreign Keys:\n");
                    hasForeignKeys = true;
                }
                sb.append(" * - ").append(entry.getKey()).append(" → ").append(entry.getValue().foreignKeyReference).append("\n");
            }
        }
        
        sb.append(" */\n");
        sb.append("public class ").append(className).append(" implements Serializable {\n\n");
        sb.append("    private static final long serialVersionUID = 1L;\n\n");

        // Generate fields with comprehensive comments
        for (Map.Entry<String, ColumnInfo> entry : columns.entrySet()) {
            ColumnInfo col = entry.getValue();
            String fieldName = toCamelCase(col.name, false);
            
            // Field documentation
            sb.append("    /**\n");
            sb.append("     * Database column: ").append(col.name).append("\n");
            sb.append("     * Type: ").append(col.sqlType);
            if (col.size > 0) sb.append("(").append(col.size).append(")");
            if (!col.nullable) sb.append(" NOT NULL");
            if (col.autoIncrement) sb.append(" AUTO_INCREMENT");
            sb.append("\n");
            
            if (col.defaultValue != null && !col.defaultValue.trim().isEmpty()) {
                sb.append("     * Default: ").append(col.defaultValue).append("\n");
            }
            
            if (col.isPrimaryKey) sb.append("     * Primary Key\n");
            if (col.isForeignKey) sb.append("     * Foreign Key → ").append(col.foreignKeyReference).append("\n");
            if (col.hasUniqueConstraint) sb.append("     * Unique Constraint: ").append(col.uniqueConstraintName).append("\n");
            if (col.hasCheckConstraint) sb.append("     * Check Constraint: ").append(col.checkConstraintDefinition).append("\n");
            
            sb.append("     */\n");
            
            sb.append("    private ").append(col.javaType).append(" ").append(fieldName).append(";\n\n");
        }

        // Default constructor
        sb.append("    /**\n");
        sb.append("     * Default constructor\n");
        sb.append("     */\n");
        sb.append("    public ").append(className).append("() {\n");
        sb.append("        // Initialize with default values where applicable\n");
        
        // Set default values in constructor
        for (Map.Entry<String, ColumnInfo> entry : columns.entrySet()) {
            ColumnInfo col = entry.getValue();
            if (col.defaultValue != null && !col.defaultValue.trim().isEmpty() && !col.autoIncrement) {
                String fieldName = toCamelCase(col.name, false);
                String defaultVal = formatDefaultValue(col.defaultValue, col.javaType);
                if (defaultVal != null) {
                    sb.append("        this.").append(fieldName).append(" = ").append(defaultVal).append("; // Default value\n");
                }
            }
        }
        
        sb.append("    }\n\n");

        // Constructor with all non-auto-increment fields
        List<ColumnInfo> constructorParams = new ArrayList<>();
        for (Map.Entry<String, ColumnInfo> entry : columns.entrySet()) {
            ColumnInfo col = entry.getValue();
            if (!col.autoIncrement) {
                constructorParams.add(col);
            }
        }
        
        if (!constructorParams.isEmpty()) {
            sb.append("    /**\n");
            sb.append("     * Constructor with parameters\n");
            for (ColumnInfo col : constructorParams) {
                sb.append("     * @param ").append(toCamelCase(col.name, false)).append(" ").append(col.name);
                if (col.hasCheckConstraint) {
                    sb.append(" (must satisfy: ").append(col.checkConstraintDefinition).append(")");
                }
                sb.append("\n");
            }
            sb.append("     */\n");
            sb.append("    public ").append(className).append("(");
            
            boolean first = true;
            for (ColumnInfo col : constructorParams) {
                if (!first) sb.append(", ");
                sb.append(col.javaType).append(" ").append(toCamelCase(col.name, false));
                first = false;
            }
            sb.append(") {\n");
            
            for (ColumnInfo col : constructorParams) {
                String fieldName = toCamelCase(col.name, false);
                sb.append("        this.").append(fieldName).append(" = ").append(fieldName).append(";\n");
            }
            sb.append("    }\n\n");
        }

        // Getters and setters with constraint validation comments
        for (Map.Entry<String, ColumnInfo> entry : columns.entrySet()) {
            ColumnInfo col = entry.getValue();
            String fieldName = toCamelCase(col.name, false);
            String methodName = toCamelCase(col.name, true);

            // Getter
            sb.append("    /**\n");
            sb.append("     * Gets the value of ").append(col.name).append("\n");
            sb.append("     * @return ").append(col.javaType).append(" value of ").append(col.name).append("\n");
            sb.append("     */\n");
            sb.append("    public ").append(col.javaType).append(" get").append(methodName).append("() {\n");
            sb.append("        return this.").append(fieldName).append(";\n");
            sb.append("    }\n\n");

            // Setter with constraint information
            sb.append("    /**\n");
            sb.append("     * Sets the value of ").append(col.name).append("\n");
            sb.append("     * @param ").append(fieldName).append(" new value for ").append(col.name).append("\n");
            if (!col.nullable) {
                sb.append("     * @throws IllegalArgumentException if value is null (NOT NULL constraint)\n");
            }
            if (col.hasCheckConstraint) {
                sb.append("     * Note: Value must satisfy check constraint: ").append(col.checkConstraintDefinition).append("\n");
            }
            if (col.hasUniqueConstraint) {
                sb.append("     * Note: Value must be unique (").append(col.uniqueConstraintName).append(")\n");
            }
            sb.append("     */\n");
            sb.append("    public void set").append(methodName).append("(").append(col.javaType).append(" ").append(fieldName).append(") {\n");
            
            // Add basic validation for NOT NULL
            if (!col.nullable && !col.javaType.equals("boolean") && !col.javaType.equals("Boolean")) {
                sb.append("        if (").append(fieldName).append(" == null) {\n");
                sb.append("            throw new IllegalArgumentException(\"").append(col.name).append(" cannot be null (NOT NULL constraint)\");\n");
                sb.append("        }\n");
            }
            
            sb.append("        this.").append(fieldName).append(" = ").append(fieldName).append(";\n");
            sb.append("    }\n\n");
        }

        // Validation method for all constraints
        sb.append("    /**\n");
        sb.append("     * Validates all constraints for this object\n");
        sb.append("     * @return List of constraint violations (empty if valid)\n");
        sb.append("     */\n");
        sb.append("    public java.util.List<String> validateConstraints() {\n");
        sb.append("        java.util.List<String> violations = new java.util.ArrayList<>();\n");
        
        for (Map.Entry<String, ColumnInfo> entry : columns.entrySet()) {
            ColumnInfo col = entry.getValue();
            String fieldName = toCamelCase(col.name, false);
            
            if (!col.nullable) {
                sb.append("        if (this.").append(fieldName).append(" == null) {\n");
                sb.append("            violations.add(\"").append(col.name).append(" cannot be null\");\n");
                sb.append("        }\n");
            }
            
            if (col.hasCheckConstraint) {
                sb.append("        // TODO: Implement check constraint validation for ").append(col.name).append(": ").append(col.checkConstraintDefinition).append("\n");
            }
        }
        
        sb.append("        return violations;\n");
        sb.append("    }\n\n");

        // equals method based on primary keys or all fields
        sb.append("    /**\n");
        sb.append("     * Compares this object with another for equality\n");
        sb.append("     * @param obj the object to compare with\n");
        sb.append("     * @return true if objects are equal, false otherwise\n");
        sb.append("     */\n");
        sb.append("    @Override\n");
        sb.append("    public boolean equals(Object obj) {\n");
        sb.append("        if (this == obj) return true;\n");
        sb.append("        if (obj == null || getClass() != obj.getClass()) return false;\n");
        sb.append("        ").append(className).append(" other = (").append(className).append(") obj;\n");
        
        // Use primary key for equals if available, otherwise use all fields
        List<String> equalsFields = new ArrayList<>();
        for (Map.Entry<String, ColumnInfo> entry : columns.entrySet()) {
            ColumnInfo col = entry.getValue();
            if (col.isPrimaryKey) {
                equalsFields.add(toCamelCase(col.name, false));
            }
        }
        if (equalsFields.isEmpty()) {
            for (Map.Entry<String, ColumnInfo> entry : columns.entrySet()) {
                equalsFields.add(toCamelCase(entry.getValue().name, false));
            }
        }
        
        sb.append("        return ");
        boolean first = true;
        for (String field : equalsFields) {
            if (!first) sb.append(" && ");
            sb.append("Objects.equals(this.").append(field).append(", other.").append(field).append(")");
            first = false;
        }
        sb.append(";\n");
        sb.append("    }\n\n");

        // hashCode method
        sb.append("    /**\n");
        sb.append("     * Generates hash code for this object\n");
        sb.append("     * @return hash code\n");
        sb.append("     */\n");
        sb.append("    @Override\n");
        sb.append("    public int hashCode() {\n");
        sb.append("        return Objects.hash(");
        sb.append(String.join(", ", equalsFields.stream().map(f -> "this." + f).toArray(String[]::new)));
        sb.append(");\n");
        sb.append("    }\n\n");

        // toString method
        sb.append("    /**\n");
        sb.append("     * Returns string representation of this object\n");
        sb.append("     * @return string representation\n");
        sb.append("     */\n");
        sb.append("    @Override\n");
        sb.append("    public String toString() {\n");
        sb.append("        return \"").append(className).append("{\" +\n");
        first = true;
        for (Map.Entry<String, ColumnInfo> entry : columns.entrySet()) {
            String fieldName = toCamelCase(entry.getValue().name, false);
            if (!first) sb.append(" +\n");
            sb.append("                \"").append(first ? "" : ", ").append(fieldName).append("=\" + ").append(fieldName);
            first = false;
        }
        sb.append(" +\n                '}';\n");
        sb.append("    }\n");

        sb.append("}\n");

        // Write to file
        FileWriter fw = new FileWriter(OUTPUT_FOLDER + className + ".java");
        fw.write(sb.toString());
        fw.close();
        
        System.out.println("Generated: " + className + ".java");
    }

    static String formatDefaultValue(String defaultValue, String javaType) {
        if (defaultValue == null || defaultValue.trim().isEmpty()) return null;
        
        String def = defaultValue.trim();
        
        // Handle common PostgreSQL default value patterns
        if (def.startsWith("'") && def.endsWith("'")) {
            // String literal
            if (javaType.equals("String")) {
                return "\"" + def.substring(1, def.length() - 1) + "\"";
            }
        } else if (def.matches("\\d+")) {
            // Numeric literal
            if (javaType.equals("Integer")) return def;
            if (javaType.equals("Long")) return def + "L";
            if (javaType.equals("Double")) return def + ".0";
        } else if (def.equalsIgnoreCase("true") || def.equalsIgnoreCase("false")) {
            // Boolean literal
            if (javaType.equals("Boolean")) return def.toLowerCase();
        } else if (def.equalsIgnoreCase("now()") || def.contains("CURRENT_TIMESTAMP")) {
            // Timestamp functions - can't set as static default
            return null;
        }
        
        return null; // Can't convert, skip
    }

    static Map<String, String> getCheckConstraints(Connection conn, String tableName) throws SQLException {
        Map<String, String> constraints = new HashMap<>();
        
        String sql = """
            SELECT 
                tc.constraint_name,
                cc.check_clause,
                ccu.column_name
            FROM information_schema.table_constraints tc
            JOIN information_schema.check_constraints cc ON tc.constraint_name = cc.constraint_name
            LEFT JOIN information_schema.constraint_column_usage ccu ON tc.constraint_name = ccu.constraint_name
            WHERE tc.table_name = ? 
            AND tc.constraint_type = 'CHECK'
            AND tc.table_schema = 'public'
            """;
            
        try (PreparedStatement stmt = conn.prepareStatement(sql)) {
            stmt.setString(1, tableName);
            ResultSet rs = stmt.executeQuery();
            
            while (rs.next()) {
                String constraintName = rs.getString("constraint_name");
                String checkClause = rs.getString("check_clause");
                String columnName = rs.getString("column_name");
                
                if (columnName != null) {
                    constraints.put(columnName, checkClause);
                } else {
                    // Table-level constraint
                    constraints.put(constraintName, checkClause);
                }
            }
        }
        
        return constraints;
    }

    static Map<String, String> getUniqueConstraints(Connection conn, String tableName) throws SQLException {
        Map<String, String> constraints = new HashMap<>();
        
        String sql = """
            SELECT 
                tc.constraint_name,
                ccu.column_name
            FROM information_schema.table_constraints tc
            JOIN information_schema.constraint_column_usage ccu ON tc.constraint_name = ccu.constraint_name
            WHERE tc.table_name = ? 
            AND tc.constraint_type = 'UNIQUE'
            AND tc.table_schema = 'public'
            """;
            
        try (PreparedStatement stmt = conn.prepareStatement(sql)) {
            stmt.setString(1, tableName);
            ResultSet rs = stmt.executeQuery();
            
            while (rs.next()) {
                String constraintName = rs.getString("constraint_name");
                String columnName = rs.getString("column_name");
                constraints.put(columnName, constraintName);
            }
        }
        
        return constraints;
    }

    static String mapToJavaType(String sqlType) {
        switch (sqlType.toLowerCase()) {
            case "varchar":
            case "text":
            case "char":
            case "bpchar":
                return "String";
            case "int4":
            case "serial":
            case "integer":
                return "Integer";
            case "int8":
            case "bigint":
            case "bigserial":
                return "Long";
            case "float8":
            case "double":
                return "Double";
            case "float4":
            case "real":
                return "Float";
            case "numeric":
            case "decimal":
                return "java.math.BigDecimal";
            case "bool":
            case "boolean":
                return "Boolean";
            case "date":
                return "java.time.LocalDate";
            case "timestamp":
            case "timestamptz":
            case "timestamp without time zone":
                return "java.time.LocalDateTime";
            case "time":
                return "java.time.LocalTime";
            case "uuid":
                return "java.util.UUID";
            case "json":
            case "jsonb":
                return "String";
            default:
                return "String"; // fallback
        }
    }

    static String toCamelCase(String str, boolean capitalizeFirst) {
        StringBuilder result = new StringBuilder();
        for (String part : str.split("_")) {
            if (part.isEmpty()) continue;
            result.append(part.substring(0, 1).toUpperCase()).append(part.substring(1).toLowerCase());
        }
        if (!capitalizeFirst && result.length() > 0)
            result.replace(0, 1, result.substring(0, 1).toLowerCase());
        return result.toString();
    }

    static Set<String> getPrimaryKeys(DatabaseMetaData meta, String tableName) throws SQLException {
        Set<String> keys = new HashSet<>();
        ResultSet rs = meta.getPrimaryKeys(null, null, tableName);
        while (rs.next()) {
            keys.add(rs.getString("COLUMN_NAME"));
        }
        return keys;
    }

    static Map<String, String> getForeignKeys(DatabaseMetaData meta, String tableName) throws SQLException {
        Map<String, String> fks = new HashMap<>();
        ResultSet rs = meta.getImportedKeys(null, null, tableName);
        while (rs.next()) {
            String fkCol = rs.getString("FKCOLUMN_NAME");
            String pkTable = rs.getString("PKTABLE_NAME");
            String pkCol = rs.getString("PKCOLUMN_NAME");
            fks.put(fkCol, pkTable + "." + pkCol);
        }
        return fks;
    }
    
    static Map<String, IndexInfo> getIndexes(DatabaseMetaData meta, String tableName) throws SQLException {
        Map<String, IndexInfo> indexes = new HashMap<>();
        ResultSet rs = meta.getIndexInfo(null, null, tableName, false, false);
        
        while (rs.next()) {
            String indexName = rs.getString("INDEX_NAME");
            if (indexName == null) continue;
            
            // Skip primary key indexes as they're handled separately
            if (indexName.toLowerCase().contains("pkey") || indexName.toLowerCase().contains("primary")) {
                continue;
            }
            
            String columnName = rs.getString("COLUMN_NAME");
            boolean unique = !rs.getBoolean("NON_UNIQUE");
            
            IndexInfo indexInfo = indexes.computeIfAbsent(indexName, k -> new IndexInfo());
            indexInfo.name = indexName;
            indexInfo.unique = unique;
            indexInfo.columns.add(columnName);
        }
        
        return indexes;
    }
    
    // Helper classes
    static class ColumnInfo {
        String name;
        String javaType;
        String sqlType;
        int size;
        boolean nullable;
        boolean autoIncrement;
        String defaultValue;
        boolean isPrimaryKey;
        boolean isForeignKey;
        String foreignKeyReference;
        boolean hasCheckConstraint;
        String checkConstraintDefinition;
        boolean hasUniqueConstraint;
        String uniqueConstraintName;
    }
    
    static class IndexInfo {
        String name;
        boolean unique;
        List<String> columns = new ArrayList<>();
    }
}
